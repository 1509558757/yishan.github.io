---
title: 多线程之原子性
date: 2021-01-14 20:56:12
tags:
- java基础
- 多线程
---
### 原子性

<!--more-->

- 所谓原子性是指在一次操作或者多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行**多个操作是一个不可以分割的整体**

##### 示例

```java
package com.yishan.yuanzi;

/**
 * @author : yishan
 * @date : 2021-01-14 21:00
 */
public class Test implements Runnable {
    private int count = 0;

    @Override
    public volatile void run() {
        for (int i = 0; i < 100; i++) {
            //1.从共享数据中读取共享数据到本线程栈中
            //2.修改本线程栈中变量副本的值
            //3.会吧本线程栈中变量副本的值赋值给共享数据
            count++;
            System.out.println("已经送了" + count+"个了");
        }

    }
}
```

##### 测试

```java
package com.yishan.yuanzi;

/**
 * @author : yishan
 * @date : 2021-01-14 21:02
 */
public class Main {
    public static void main(String[] args) {
        Test test = new Test();

        for (int i = 0; i < 100; i++) {
           new Thread(test).start();
        }
    }
}
```

### 结论

- volatile关键字不可以保证原子性，但是synchronized同步代码块可以保证原子性

### AtomicInteger_原子性

```java
package com.yishan.atomic;

import java.util.concurrent.atomic.AtomicInteger;

/**
 * @author : yishan
 * @date : 2021-01-14 09:43
 */
public class Test01 {
    public static void main(String[] args) {
        AtomicInteger ai = new AtomicInteger();
        //默认初始值为0
        System.out.println(ai);

        AtomicInteger atomicInteger = new AtomicInteger(10);
        System.out.println(atomicInteger);

        //默认初始值为10
        System.out.println(atomicInteger.get());

        //以原子方式将当前值加1，  返回自增前的值
        System.out.println(atomicInteger.getAndIncrement());
        System.out.println(atomicInteger.get());

        //以原子方式将当前值加1，   返回自增后的值
        System.out.println(atomicInteger.incrementAndGet());
        System.out.println(atomicInteger.get());

        //以原子方式，将输入的数值和实例中的值相加，并返回结果
        System.out.println(atomicInteger.addAndGet(10));
        System.out.println(atomicInteger.get());

        //以原子方式，获取输入的数值并更改实例中的值，并返回结果
        System.out.println(atomicInteger.getAndSet(100));
        System.out.println(atomicInteger.get());
    }
}
```

### AtomicInteger_原理

##### 自旋+CAS算法

- 在修改共享数据的时候，把原来的旧值记录下来了
- 如果现在内存中的值和原来的旧值一样，证明没有其他线程操作过内存值，则修改成功
- 如果现在内存中的值和原来的旧值不一样了，证明已经有其他线程操作过内存值了，则修改失败，需要重新获取现在最近的值，再次进行操作，这个重新获取就是自旋。

### AtomicInteger_源码解析

```java
//先自增，然后获取自增后的结果
 public final int incrementAndGet() {
       //+1  自增后的结果
       //this 就表示当前的atomicInteger（值）
       //1 自增一次
       return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
   }

 public final int getAndAddInt(Object var1, long var2, int var4) {
         //var5 旧值
         int var5;
         //自旋的过程
         do {
             //不断的获取旧值
             var5 = this.getIntVolatile(var1, var2);
             //如果这个方法的返回值为false,那么就继续自旋
             //如果这个方法的返回值为true,那么自旋结束
             //var1 表示的就是内存值
             //var5 旧值
             //var5 + var4 修改后的值
         } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));
             //作用：比较内存中的值，旧值是否相等，如果相等就把修改后的值写到内存中，返回true.表示修改成功
             //                        如果不相等，无法把修改后的值写到内存中，返回falses,表示修改失败
             //如果修改失败，那么继续自旋
         return var5;
     }
```





### synchronized和CAS的区别

- 相同点：在多线程情况下，都可以保证共享数据的安全性。
- 不同点：
  - synchronized总是从最坏的角度出发，认为每次获取数据的时候，别人都有可能修改，所以在每次操作共享数据之前，都会上锁。（**悲观锁**）
  - CAS是从乐观的角度出来，假设每次获取数据别人都不会修改，所以不会上锁。只不过在修改共享数据的时候，会检查一下，别人有没有修改过这个数据。如果别人修改过，那么我再次获取现在最新的值。
  - 如果别人没有修改过，那么我现在直接修改共享数据的值。（**乐观锁**）