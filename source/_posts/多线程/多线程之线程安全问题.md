---
title: 多线程之线程安全问题
date: 2021-01-13 18:14:25
tags:
- 多线程
- java基础
---

#  线程安全问题

<!--more-->

### 同步代码块 

```java
package com.yishan.test;

/**
 * @author : yishan
 * @date : 2021-01-11 16:37
 */
public class TicketNum implements Runnable {
    public int TicketNum = 100;
    //添加锁对象
    private Object obj = new Object();
    @Override
    public void run() {

            while (true){
                //同步代码块
                synchronized (obj){
                if (TicketNum<=0){
                    break;
                }else{
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    TicketNum--;
                    System.out.println(Thread.currentThread().getName()+"还剩下"+TicketNum+"张票");
                }
            }
        }
    }
}
```

##### 测试

```java
package com.yishan.test;

/**
 * @author : yishan
 * @date : 2021-01-11 16:37
 */
public class MainClass {
    public static void main(String[] args) {

        TicketNum ticketNum = new TicketNum();
        Thread t1 = new Thread(ticketNum);
        Thread t2 = new Thread(ticketNum);
        Thread t3 = new Thread(ticketNum);

        t1.setName("一号窗口");
        t2.setName("二号窗口");
        t3.setName("三号窗口");

        t1.start();
        t2.start();
        t3.start();
    }
}
```

### 锁对象唯一

- 使用静态Static关键字修饰数据和锁对象，进行共享同一份数据,，可以解决线程安全问题

```java
package com.yishan.test;

/**
 * @author : yishan
 * @date : 2021-01-11 16:37
 */
public class TicketNum2 extends Thread {
    //锁对象唯一，静态关键字共享
    private static Object obj = new Object();
    private static int TicketNum = 100;

    @Override
    public void run() {

        while (true) {
            //锁对象唯一
            synchronized (obj) {
                if (TicketNum <= 0) {
                    break;
                } else {
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    TicketNum--;
                    System.out.println("还剩下" + TicketNum + "张票");
                }
            }
        }
    }
}
```

##### 测试

```java
package com.yishan.test;

/**
 * @author : yishan
 * @date : 2021-01-11 16:37
 */
public class MainClass2 {
    public static void main(String[] args) {

        TicketNum2 t1 = new TicketNum2();
        TicketNum2 t2 = new TicketNum2();
        TicketNum2 t3 = new TicketNum2();

        t1.setName("线程一");
        t1.setName("线程二");
        t1.setName("线程三");

        t1.start();
        t2.start();
        t3.start();

    }
}
```

### 同步方法

##### 同步方法和同步代码块的区别：

- 同步代码块可以锁住指定代码，同步方法是锁住方法中的所有代码
- 同步代码块可以指定锁对象，同步方法不能指定锁对象

> 同步方法的锁对象是 this
>
> > 同步静态方法的所对象是 类名.class

```java
package com.yishan.test;

/**
 * @author : yishan
 * @date : 2021-01-13 18:37
 */
public class Test03 extends Thread {
    private int TicketNum = 100;

    @Override
    public void run() {
        while (true) {
            if ("窗口一".equals(Thread.currentThread().getName())) {
                boolean result = synchronizedMethod();
                if (result) {
                    break;
                }
            }
            if ("窗口二".equals(Thread.currentThread().getName())) {
                synchronized (this) {
                    if (TicketNum == 0) {
                        break;
                    } else {
                        try {
                            Thread.sleep(10);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        TicketNum--;
                        System.out.println(Thread.currentThread().getName() + "还剩下" + TicketNum + "张票");

                    }
                }
            }
        }
    }

    /**
     * 同步方法
     *
     * @return
     */
    private synchronized boolean synchronizedMethod() {
        if (TicketNum == 0) {
            return true;
        } else {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            TicketNum--;
            System.out.println(Thread.currentThread().getName() + "还剩下" + TicketNum + "张票");
            return false;
        }
    }
}
```

##### 测试

```java
package com.yishan.test;

/**
 * @author : yishan
 * @date : 2021-01-13 18:46
 */
public class Test03Demo {
    public static void main(String[] args) {
        Test03 test03 = new Test03();

        Thread thread = new Thread(test03);
        Thread thread1 = new Thread(test03);

        thread.setName("窗口一");
        thread1.setName("窗口二");

        thread.start();
        thread1.start();

    }
}
```

### Lock锁

- Lock中提供了获得锁和释放锁的方法
- void lock()：获得锁
-  void unlock()：释放锁

##### Lock是接口不能直接实例化，采用其实现类ReentrantLock来实例化

- ReentrantLock()：创建一个ReemtrantLock的实例



```java
package com.yishan.lock;

import java.util.concurrent.locks.ReentrantLock;

/**
 * @author : yishan
 * @date : 2021-01-13 10:19
 */
public class MyLock implements Runnable {
    private int ticketNum = 100;
    //实例化 ReentrantLock
    private ReentrantLock lock = new ReentrantLock();

    @Override
    public void run() {
        while (true) {
            try {
                //获得锁
                lock.lock();
                if (ticketNum <= 0) {
                    break;
                } else {
                    Thread.sleep(100);
                    ticketNum--;
                    System.out.println(Thread.currentThread().getName() + "还剩下" + ticketNum + "张票");
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                //释放锁
                lock.unlock();
            }
        }
    }
}
```

##### 测试

```java
package com.yishan.lock;

/**
 * @author : yishan
 * @date : 2021-01-13 10:26
 */
public class MyLockTest {
    public static void main(String[] args) {
        MyLock myLock = new MyLock();

        Thread thread = new Thread(myLock);
        Thread thread1 = new Thread(myLock);

        thread.start();
        thread1.start();
    }
}
```

