---
title: 多线程之线程池
date: 2021-01-14 18:58:31
tags:
- java基础
- 多线程
---

# 线程池

<!--more-->

### 1.默认线程池

```java
package com.yishan.pooltest;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * @author : yishan
 * @date : 2021-01-14 19:04
 */
public class Pool01 {
    public static void main(String[] args) throws InterruptedException {
        //创建一个默认的线程池，默认是空的，最大值为int类型的最大值
        ExecutorService executorService = Executors.newCachedThreadPool();
        //Executors 可以帮助我们创建线程池对象
        //ExecutorService  可以帮助我们管理线程池
        executorService.submit(()->{
            System.out.println(Thread.currentThread().getName()+"在执行了！");
        });

        //存在sleep方法，只会创建一个线程，第二个线程会默认复用第一个线程
        //不存在Sleep方法，在第一个线程还没有提交，第二个线程就过来了，所以会创建两个线程
        Thread.sleep(100);

        executorService.submit(()->{
            System.out.println(Thread.currentThread().getName()+"在执行了！");
        });

        //关闭连接池
        executorService.shutdown();
    }

}
```

### 2.指定上限的线程池

```java
package com.yishan.pooltest;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadPoolExecutor;

/**
 * @author : yishan
 * @date : 2021-01-14 19:13
 */
public class Pool02 {
    public static void main(String[] args) {
        //创建一个线程池，默认线程数为0，参数为可容纳的最大线程数量
        ExecutorService executorService = Executors.newFixedThreadPool(10);

        ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) executorService;
        //获取当前池子中的线程数
        int size = threadPoolExecutor.getPoolSize();
        System.out.println("size = " + size);

        executorService.submit(()->{
            System.out.println(Thread.currentThread().getName()+"在执行了！");
        });
        executorService.submit(()->{
            System.out.println(Thread.currentThread().getName()+"在执行了！");
        });

        //当前池子中的线程数
        int poolSize = threadPoolExecutor.getPoolSize();
        System.out.println("poolSize = " + poolSize);
        //关闭池
        executorService.shutdown();
    }
}
```

### 自定义线程池

- 优先调用核心线程，在阻塞队列达到最大值后，调用临时线程

```java
package com.yishan.pooltest;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

/**
 * 自定义线程池
 *
 * @author : yishan
 * @date : 2021-01-14 19:27
 */
public class Pool03 {

    public static void main(String[] args) {
        /**
         * 1.核心线程数量
         * 2.最大线程数量
         * 3.空闲线程最大存活时间
         * 4.空闲线程最大存活时间单位
         * 5.阻塞队列
         * 6.默认创建线程的工厂
         * 7.拒绝策略
         */
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
                2,
                5,
                2,
                TimeUnit.SECONDS,
                new ArrayBlockingQueue<>(10),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.AbortPolicy()
        );
        threadPoolExecutor.submit(() -> {
            System.out.println(Thread.currentThread().getName() + "在执行了！");
        });
        threadPoolExecutor.submit(() -> {
            System.out.println(Thread.currentThread().getName() + "在执行了！");
        });
        threadPoolExecutor.submit(() -> {
            System.out.println(Thread.currentThread().getName() + "在执行了！");
        });

        threadPoolExecutor.shutdown();
    }

}
```

##### 任务拒绝策略

- 1.new ThreadPoolExecutor.AbortPolicy()   丢弃任务并抛出RejectedExecutionException异常，这是默认的策略
- 2.new ThreadPoolExecutor.DiscardPolicy()  直接丢弃任务，不抛出异常，不推荐此做法
- 3.new ThreadPoolExecutor.DiscardOldestPolicy()  直接抛弃队列中等待最久的任务，然后将当前任务加入到队列中
- 4.new ThreadPoolExecutor.CallerRunsPolicy()  调用其他线程进行执行