---
title: 多线程开篇！
date: 2020-09-26 16:04:24
tags: [java基础,多线程]
---

### 进程与线程（Process与Thread）
<!--more-->
#### 进程
- 根本区别：作为资源分配的单位
- 开销：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销。
- 所处环境：在操作系统中能同时运行多个任务（程序）
- 分配内存：系统在运行的时候会为每个进程分配不同的内存区域
- 包含关系：没有线程的进程是可以被看做单线程的，如果一个进程内拥有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的。
#### 线程
- 根本区别：调度和执行的单位
- 开销：线程可以看成时轻量级的进程，同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器（pc）,线程切换的开销小。
- 分配内存：除了CPU之外，不会为线程分配内存（线程所使用的资源是它所属的进程的资源），线程组只能共享资源
- 包含关系：线程是进程的一部分，所以线程有的时候被称为是轻量级进程。

#### 注意
- 很多多线程是模拟出来的，真正的多线程是指有多个cpu,即多核。如服务器。如果是模拟出来的多线程，即一个cpu的情况下，在同一个时间点，cpu只能执行一个代码，因为切换的很快，所以就有同时执行的错觉。

#### 核心概念
- 线程就是独立的执行路径；
- 在程序运行时，即使没有自己创建线程，后台也会存在多个线程，如gc线程、主线程；
- main()称之为主线程，为系统的入口点，用于执行整个程序；
- 在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，先后顺序是不能认为的干预的；
- 对用一份资源操作时，会存在资源抢夺的问题，需要加入并发控制；
- 线程会带来额外的开销，如cpu调度时间，并发控制开销；
- 每个线程在自己的工作内存交互，加载和存储主内存控制不当会造成数据不一致。

#### 创建线程的三种方式
- 1.继承Thread类，重写run（）方法，调用子类对象的start()方法；
- 2.实现Runnable接口，重写run()方法，通过new Thread对象来调用start()方法；
- 3.实现Callable接口，重写Call（）方法；（JUC并发包下的）

##### 创建线程方式一：继承Thread类
```java
    package com.yishan.thread;

    /**
    * 创建线程方式一：
    * 1.创建：继承Thread+重写run
    * 2.启动：创建子类对象+start
    * @author : yishan
    * @date : 2020-09-26 16:37
    */
    public class StartThread extends Thread {
        /**
        * 线程的入口点
        */
        @Override
        public void run() {
            for (int i=0;i<20;i++ ){
                System.out.println("一遍听歌");
            }
        }

        public static void main(String[] args) {
            //创建子类对象
            StartThread st = new StartThread();
            //启动
            st.start();//不保证立即启动，由CPU进行调用
            //st.run();
            for (int i=0;i<20;i++ ){
                System.out.println("一遍coding");
            }

        }
    }
```

##### 继承Thread类 图片下载

```java
    package com.yishan.thread;

    import org.apache.commons.io.FileUtils;

    import java.io.File;
    import java.io.IOException;
    import java.net.MalformedURLException;
    import java.net.URL;

    /**
    * 下载图片
    * @author : yishan
    * @date : 2020-10-12 19:51
    */
    public class WebDownloader {
        /**
        * 下载
        * @param url
        * @param name
        */
        public void download(String url,String name){
            try {
                FileUtils.copyURLToFile(new URL(url),new File(name));
            }catch (MalformedURLException e) {
                e.printStackTrace();
                System.out.println("不合法的URL");
            }catch (IOException e) {
                e.printStackTrace();
                System.out.println("下载失败");
            }
        }
    }
```




```java
        package com.yishan.thread;

        /**
        * @author : yishan
        * @date : 2020-10-12 19:57
        */
        public class TDownloader extends Thread{
            private String url;//远程路径
            private String name;//存储名字

            public TDownloader(String url, String name) {
                this.url = url;
                this.name = name;
            }

            @Override
            public void run() {
                WebDownloader wd = new WebDownloader();
                wd.download(url,name);
            }

            public static void main(String[] args) {
                TDownloader td1 = new TDownloader("https://s1.ax1x.com/2020/10/12/0WFx3Q.png","td1.jpg");
                TDownloader td2 = new TDownloader("https://s1.ax1x.com/2020/10/12/0Wk9un.png","td2.jpg");
                TDownloader td3 = new TDownloader("https://s1.ax1x.com/2020/10/12/0WkFEV.png","td3.jpg");

                //启动三个线程
                td1.start();
                td2.start();
                td3.start();
            }
        }
```

##### 创建线程方式二：实现Runnable

```java
    package com.yishan.thread;

    /**
    * 创建线程方式二：
    * 1.创建：实现Runnable + 重写run
    * 2.启动：创建实现类对象 + Thread对象 + start
    *
    * 推荐：避免单继承的局限性，优先使用接口
    * 方便共享资源
    * @author : yishan
    * @date : 2020-09-26 16:37
    */
    public class StartRun implements Runnable{
        /**
        * 线程的入口点
        */
        @Override
        public void run() {
            for (int i=0;i<20;i++ ){
                System.out.println("一遍听歌");
            }
        }

        public static void main(String[] args) {
            /*
            //创建实现类对象
            StartRun sr = new StartRun();
            //创建代理类对象
            Thread t = new Thread(sr);
            //启动
            t.start();//不保证立即启动，由CPU进行调用
            */
            new Thread(new StartRun()).start();

            //st.run();
            for (int i=0;i<20;i++ ){
                System.out.println("一遍coding");
            }

        }
    }
```

##### 实现Runnable 图片下载

```java
    package com.yishan.thread;

    /**
    * @author : yishan
    * @date : 2020-10-12 19:57
    */
    public class IDownloader implements Runnable{
        private String url;//远程路径
        private String name;//存储名字

        public IDownloader(String url, String name) {
            this.url = url;
            this.name = name;
        }

        @Override
        public void run() {
            WebDownloader wd = new WebDownloader();
            wd.download(url,name);
        }

        public static void main(String[] args) {
            IDownloader td1 = new IDownloader("https://s1.ax1x.com/2020/10/12/0WFx3Q.png","td1.jpg");
            IDownloader td2 = new IDownloader("https://s1.ax1x.com/2020/10/12/0Wk9un.png","td2.jpg");
            IDownloader td3 = new IDownloader("https://s1.ax1x.com/2020/10/12/0WkFEV.png","td3.jpg");

            //启动三个线程
            new Thread(td1).start();
            new Thread(td2).start();
            new Thread(td3).start();
        }
    }
```

##### 共享资源，并发（线程安全）

```java
    package com.yishan.thread;

    /**
    * 共享资源，并发（线程安全）
    * @author : yishan
    * @date : 2020-10-13 13:58
    */
    public class Web12306 implements Runnable{

        private int ticketNums = 99;
        @Override
        public void run() {
            while (true){
                if (ticketNums <= 0){
                    break;
                }
                try {
                    Thread.sleep(200);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName()+"-->"+ticketNums--);
            }
        }

        public static void main(String[] args) {
            //一份资源
            Web12306 web = new Web12306();
            //多个代理
            new Thread(web,"张三").start();
            new Thread(web,"李四").start();
            new Thread(web,"王二").start();
        }
    }
```

##### 龟兔赛跑（Runnable）

        package com.yishan.thread;


```java
    /**
    * 龟兔赛跑
    * @author : yishan
    * @date : 2020-10-13 14:10
    */
    public class Racer implements Runnable{
        private  String winner;//胜利者
        @Override
        public void run() {
            for (int steps = 1;steps <= 100;steps++){
                //模拟休息
                if (Thread.currentThread().getName().equals("rabbit") && steps % 10 == 0){
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println(Thread.currentThread().getName()+"-->"+steps++);
                //比赛是否结束
                boolean flag = gameOver(steps);
                if(flag){
                    break;
                }
            }
        }

        private boolean gameOver(int steps){
            if(winner!=null){
                return true;
            }else{
                if(steps == 100){//存在胜利者
                    winner = Thread.currentThread().getName();
                    System.out.println("winner-->"+winner);
                    return true;
                }
            }
            return false;
        }

        public static void main(String[] args) {
            Racer racer = new Racer();
            new Thread(racer,"tortoise").start();
            new Thread(racer,"rabbit").start();
        }
    }
```


#### 创建线程的方式三：实现Callable接口

```java
    package com.yishan.thread;

    import java.util.concurrent.*;

    /**
    * 了解创建线程的方式三：实现Callable接口
    * @author : yishan
    * @date : 2020-10-12 19:57
    */
    public class CDownloader implements Callable<Boolean> {
        private String url;//远程路径
        private String name;//存储名字

        public CDownloader(String url, String name) {
            this.url = url;
            this.name = name;
        }

        @Override
        public Boolean call() throws Exception {
            WebDownloader wd = new WebDownloader();
            wd.download(url, name);
            return true;
        }

        public static void main(String[] args) throws ExecutionException, InterruptedException {
            CDownloader cd1 = new CDownloader("https://s1.ax1x.com/2020/10/12/0WFx3Q.png", "td1.jpg");
            CDownloader cd2 = new CDownloader("https://s1.ax1x.com/2020/10/12/0Wk9un.png", "td2.jpg");
            CDownloader cd3 = new CDownloader("https://s1.ax1x.com/2020/10/12/0WkFEV.png", "td3.jpg");

            //创建执行服务
            ExecutorService ser = Executors.newFixedThreadPool(3);
            //提交执行
            Future<Boolean> result1 = ser.submit(cd1);
            Future<Boolean> result2 = ser.submit(cd2);
            Future<Boolean> result3 = ser.submit(cd3);
            //获取结果
            boolean r1 = result1.get();
            boolean r2 = result1.get();
            boolean r3 = result1.get();
            //关闭服务
            ser.shutdownNow();
        }
    }
```

##### 龟兔赛跑（Callable）

        package com.yishan.thread;


```java
    import java.util.concurrent.*;

    /**
    * 龟兔赛跑
    * @author : yishan
    * @date : 2020-10-13 14:10
    */
    public class CRacer implements Callable<Integer> {
        private  String winner;//胜利者
        @Override
        public Integer call() throws Exception{
            for (int steps = 1;steps <= 100;steps++){
                //模拟休息
                if (Thread.currentThread().getName().equals("pool-1-thread-1") && steps % 10 == 0){
                    Thread.sleep(100);
                }
                System.out.println(Thread.currentThread().getName()+"-->"+steps++);
                //比赛是否结束
                boolean flag = gameOver(steps);
                if(flag){
                    return steps;
                }
            }
            return null;
        }

        private boolean gameOver(int steps){
            if(winner!=null){
                return true;
            }else{
                if(steps == 100){//存在胜利者
                    winner = Thread.currentThread().getName();
                    System.out.println("winner-->"+winner);
                    return true;
                }
            }
            return false;
        }

        public static void main(String[] args) throws ExecutionException, InterruptedException {
            CRacer racer = new CRacer();
            //创建执行服务
            ExecutorService ser = Executors.newFixedThreadPool(2);
            //提交执行
            Future<Integer> result1 = ser.submit(racer);
            Future<Integer> result2 = ser.submit(racer);
            //获取结果
            Integer r1 = result1.get();
            Integer r2 = result2.get();
            System.out.println(r1+"-->"+r2);
            //关闭服务
            ser.shutdownNow();
        }
    }
```

