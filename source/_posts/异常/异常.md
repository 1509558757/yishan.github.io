---
title: 异常
date: 2020-08-15 12:41:20
tags: [java基础,异常]
---
## 异常概念
<!--more-->
javas是采用面向对象的方式来处理异常的。处理过程：

- 1.抛出异常：在执行一个方法时，如果发生异常，则这个方法生成代表该异常的一个对象，停止当前执行路径，并把异常对象提交给JRE
- 2.捕获异常：JRE得到该异常后，寻找相应的代码来处理该异常。JRE在方法的调用栈中查找，从生成异常的方法开始回溯，知道找到相应的异常处理代码为止。

![异常](https://s1.ax1x.com/2020/08/15/dFNmrt.png)

## Exception

Exception是程序本身能够处理的异常，如：空指针异常(NullPointerException)、数组下标越界异常(ArrayIndexOutOfBoundsException)、类型转换异常(ClassCastException)、算术异常（ArithmeticException）等。

Exception类时所有异常类的父类，其子类对应了各种各样可能出现的异常事件。通常java的异常可分为：
- 1.RuntimeException运行时异常
- 2.CheckedException已检查异常

## RuntimeException运行时异常

大多数都是逻辑错误，需要程序猿去使用代码进行完善的异常

比如：试图去除以零等等

## CheckedException已检查异常

也叫编译器异常：使用try/catch捕获异常、使用throws声明异常

    package cn.yishan.exception;

    import java.io.FileNotFoundException;
    import java.io.FileReader;
    import java.io.IOException;

    /**
    * 使用try-catch处理异常
    * @author yishan
    */
    public class Test02 {
        public static void main(String[] args) {
            FileReader reader = null;
            try {
                reader = new FileReader("d:/a.txt");

                char c1 = (char) reader.read();
                System.out.println(c1);
                //子类异常在父类异常前面
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            }finally {
                try {
                    if (reader!=null){
                        reader.close();
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }


    package cn.yishan.exception;

    import java.io.FileNotFoundException;
    import java.io.FileReader;
    import java.io.IOException;

    /**
    *使用throws声明异常
    *将异常抛出，谁调用我谁处理异常
    * @author yishan
    */
    public class Test03 {
        public static void main(String[] args) throws IOException {
            readMyFile();
        }

        public static void readMyFile() throws IOException {
            FileReader reader = null;
                reader = new FileReader("d:/a.txt");

                char c1 = (char) reader.read();
                System.out.println(c1);
                //子类异常在父类异常前面
                }
            }
## 手动抛出异常_自定义异常总结
- 1.在程序中，可能会遇到JDK提供的任何标准异常类都无法充分描述清楚我们想要表达的问题，这种情况下可以创建自己的异常类，即自定义异常类。
- 2.自定义异常类只需从Exception类或者它的子类派生一个子类即可。
- 3.自定义异常类如果继承Exception类，则为受检查异常，必须对其进行处理；如果不想处理，可以让自定义异常类继承运行时异常RuntimeException类。
- 4.习惯上，自定义异常类应该包含2个构造器：一个是默认的构造器，另一个是带有详细信息的构造器。

        package cn.yishan.exception;
        /**
        * 继承运行时异常进行自定义异常
        * @author yishan
        */
        public class Test04 {
            public static void main(String[] args) {
                Person p = new Person();
                p.setAge(-10);
            }
        }

        class Person{
            private int age;

            public int getAge() {
                return age;
            }

            public void setAge(int age) {
                if (age<0){
                    throw new IllegalAgeException("年龄不能为负数");
                }
                this.age = age;
            }
        }

        class IllegalAgeException extends RuntimeException{
            public IllegalAgeException(){

            }
            public IllegalAgeException(String msg){
                super(msg);
            }
        }
#### 使用异常机制的建议
- 1.要避免使用异常处理代替错误处理，这样会降低程序的清晰性，并且效率低下。
- 2.处理异常不可以代替简单测试---只在异常情况下使用异常机制。
- 3.不要进行小粒度的异常处理---应该讲整个任务包装在一个try语句块中。
- 4.异常往往在高层处理