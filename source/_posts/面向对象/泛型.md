---
title: 泛型
date: 2021-01-04 17:59:36
tags: [java基础,泛型]
---
### 1.泛型

### 1.1泛型概述

<!--more-->

- 泛型的介绍

  ​	泛型是JDK5中引入的特性，它提供了编译时类型安全检测机制

- 泛型的好处

  1. 把运行时期的问题提前到了编译期间
  2. 避免了强制类型转换

- 泛型的定义格式

  - <类型>: 指定一种类型的格式.尖括号里面可以任意书写,一般只写一个字母.例如: <E> <T>
  - <类型1,类型2…>: 指定多种类型的格式,多种类型之间用逗号隔开.例如: <E,T> <K,V>

### 1.2泛型类

- 泛型类

```java
package com.yishan.fanxing;

/**
 * 自定义泛型类
 * @author : yishan
 * @date : 2021-01-04 11:27
 */
public class Box<E> {
    private E name;
    private E address;

    public Box() {
    }

    public Box(E name, E address) {
        this.name = name;
        this.address = address;
    }

    public E getName() {
        return name;
    }

    public void setName(E name) {
        this.name = name;
    }

    public E getAddress() {
        return address;
    }

    public void setAddress(E address) {
        this.address = address;
    }
}
```

- 测试类

```java
package com.yishan.fanxing;

/**
 * 测试自定义泛型
 * @author : yishan
 * @date : 2021-01-04 11:29
 */
public class TestBox {
    public static void main(String[] args) {
        Box<String> box = new Box<>();
        box.setName("王五");
        String name = box.getName();
        System.out.println("name = " + name);
    }
}
```

### 1.3泛型方法

```java
package com.yishan.fanxing;

import java.util.ArrayList;

/**
 * 自定义泛型方法
 *
 * @author : yishan
 * @date : 2021-01-04 11:47
 */
public class Test01 {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        addElement(list, "aaa", "bbb", "ccc", "ddd", "eee");
        System.out.println("list = " + list);

        System.out.println("---------------------------------------------");

        ArrayList<Integer> list1 = new ArrayList<>();
        addElement(list1, 111, 222, 333, 444, 555);
        System.out.println("list1 = " + list1);

    }

    /**
     * 集合添加操作
     *      需要指定相应的泛型类型
     * @param list
     * @param e
     * @param e1
     * @param e2
     * @param e3
     * @param e4
     * @param <E>
     * @return
     */
    public static <E> ArrayList<E> addElement(ArrayList<E> list, E e, E e1, E e2, E e3, E e4) {
        list.add(e);
        list.add(e1);
        list.add(e2);
        list.add(e3);
        list.add(e4);
        return list;
    }
}
```



### 1.4泛型接口

```java
package com.yishan.fanxing;

/**
 * 泛型接口
 *
 * @author : yishan
 * @date : 2021-01-04 15:15
 */
public class Test02 {
    public static void main(String[] args) {
        //实现泛型接口的类为定义类型，在创建对象时需要定义类型
        Studentimpl<Integer> studentimpl = new Studentimpl<>();
        studentimpl.method(123);

        StudentImpl2 studentImpl2 = new StudentImpl2();
        studentImpl2.method("aaa");

    }
}

//泛型接口
interface Person<E> {
    public abstract void method(E e);
}

//泛型类(为定义类型)
class Studentimpl<E> implements Person<E> {

    @Override
    public void method(E e) {
        System.out.println(e);
    }
}

//泛型类(定义泛型类型)
class StudentImpl2 implements Person<String> {

    @Override
    public void method(String s) {
        System.out.println(s);
    }
}
```

### 1.5类型通配符

- 类型通配符: <?>
  - ArrayList<?>: 表示元素类型未知的ArrayList,它的元素可以匹配任何的类型
  - 但是并不能把元素添加到ArrayList中了,获取出来的也是父类类型
- 类型通配符上限: <? extends 类型>
  - ArrayListList <? extends Number>: 它表示的类型是Number或者其子类型
- 类型通配符下限: <? super 类型>
  - ArrayListList <? super Number>: 它表示的类型是Number或者其父类型
- 泛型通配符的使用

public class GenericDemo4 {
    public static void main(String[] args) {
        ArrayList<Integer> list1 = new ArrayList<>();
        ArrayList<String> list2 = new ArrayList<>();
        ArrayList<Number> list3 = new ArrayList<>();
        ArrayList<Object> list4 = new ArrayList<>();

```java
    method(list1);
    method(list2);
    method(list3);
    method(list4);

    getElement1(list1);
    getElement1(list2);//报错
    getElement1(list3);
    getElement1(list4);//报错

    getElement2(list1);//报错
    getElement2(list2);//报错
    getElement2(list3);
    getElement2(list4);
}
  
// 泛型通配符: 此时的泛型?,可以是任意类型
public static void method(ArrayList<?> list){}
// 泛型的上限: 此时的泛型?,必须是Number类型或者Number类型的子类
public static void getElement1(ArrayList<? extends Number> list){}
// 泛型的下限: 此时的泛型?,必须是Number类型或者Number类型的父类
public static void getElement2(ArrayList<? super Number> list){}
}
```
