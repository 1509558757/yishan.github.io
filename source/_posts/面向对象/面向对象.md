---
title: 面向对象
date: 2020-07-31 13:17:30
tags: [java基础,jvm,垃圾回收,jvm调优]
---
### 面向对象和面向过程
<!-- more -->
- 1.都是解决问题的思维方式，都是代码组织的方式
- 2.解决简单问题可以使用面向过程
- 3.解决复杂问题：宏观上使用面向对象把握，微观处理上仍然是面向过程
### 内存分析
- java虚拟机的内存可以分为三个区域：栈stack、堆heap、方法区method area
#### 栈的特点
- 1.栈描述的是方法执行的内存模型。每个方法被调用都会创建一个栈帧（存储局部变量、操作数、方法出口等）
- 2.JVM为每个线程创建一个栈，用于存放该线程执行方法的信息（实际参数、局部变量等）
- 3.栈属于线程私有，不能实现线程间的共享！
- 4.栈的存储特性是“先进先出，后进后出”
- 5.栈是由系统自动分配，速度快！栈是一个连续的内存空间！
#### 堆的特点
- 1.堆用于存储创建好的对象和数组（数组也是对象）
- 2.JVM只有一个堆，被所有线程共享
- 3.堆是一个不连续的内存空间，分配灵活，速度慢！
#### 方法区（静态区）的特点
- 1.JVN只有一个方法区，被所有线程共享！
- 2.方法区实际也是堆，只是用于存储类、常量相关的信息！
- 3.用来存放程序中永远是不变或唯一的内容。（类信息【class对象】、静态变量、字符串常量）
### 构造方法
构造器也叫构造方法（constructor），用于对象的初始化。
- 1.通过new关键字调用
- 2.构造器虽然有返回值，但是不能定义返回值类型（返回值的类型肯定是本类），不能再构造器里使用return返回某个值。
- 3.如果我们没有定义构造器，则编译器会自动定义一个无参的构造函数。如果已定义则编译器不会自动添加！
- 4.构造器的方法名必须和类名一致！
### 垃圾回收机制（Garbage Collection）
#### 垃圾回收过程
- 1.发现无用的对象
- 2.回收无用对象占用的内存空间
#### 垃圾回收相关算法
- 1.引用计数法

    堆中每个对象都有一个引用计数。被引用一次，计数加1，被引用变量值变为null,则计数减1，直到计数为0，则表示变成无用对象，优点是算法简单，缺点是“循环引用的无用对象”无法识别。
- 2.引用可达法（根搜索算法）

    程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。
#### 通用的分代垃圾回收机制
分代垃圾回收机制，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。我们将对象分为三种状态：年轻代、年老代、持久代。JVM将堆内存划分为Eden、Survivor和Tenured/Old空间
- 1.年轻代

所有新生成的对象首先都是放在Eden区。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象，对应的是Minor GC,每次 Minor GC会清理年轻代的内存，算法采用效率较高的复制算法，频繁的操作，但是会浪费内存空间。当“年轻代”区域存放满对象后，就将对象存放到年老区域。
- 2.年老代

在年轻代中经历了N（默认15）次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。年老代对象越来越多，我们就需要启动Major GC和Full GC(全量回收)，来一次大扫除，全面清理年轻代区域和年老代区域。
- 3.持久代

用于存放静态文件，如java类、方法等。持久代对垃圾回收没有显著影响。
#### 垃圾回收过程
- 1.新创建的对象，绝大多数都会存储在Eden中
- 2.当Eden满了（或者达到一定的比例）不能创建对象，就会触发垃圾回收（GC），将无用的对象清理掉，然后剩余对象赋值到某个Survivor中，如S1,同时清空Eden区
- 3.当Eden区再次满了，会将S1中的不能清空的对象存到另外一个Survivor中，如S2，同时将Eden区中的不能清空的对象，也复制到S1中，保证Eden和S1均被清空。
- 4.重复多次（默认15次）Survivor中没有被清理的对象，则会复制到老年代Old(Tenured)区中
- 5.当Old区满了，则会触发一个一次完整的垃圾回收（Full GC）,之前新生代的垃圾回收称为（minor GC）
### JVM调优和Full GC

在对JVM调优的过程中，很大一部分工作就是对于Full GC的调节，有如下原因可能导致Full GC:
- 1.年老代（Tenured）被写满
- 2.持久代（Perm）被写满
- 3.System.gc()被显式调用（程序建议GC启动，不是调用GC）
- 4.上一次GC之后Heap的各域分配策略动态变化
### 开发中容易造成内存泄漏的操作
- 1.创建大量的无用对象

在需要大量拼接字符串时，使用了String而不是StringBuilder
- 2.静态集合类的使用

像HashMap、Vector、List等的使用最容易出现内存泄漏，这些静态变量的生命周期和应用程序一致，所有的对象Object也不能被释放
- 3.各种连接对象（IO流对象、数据库连接对象、网络连接对象）未关闭

IO流对象、数据库连接对象、网络连接对象等连接对象属于物理连接，和硬盘或者网络连接，不使用的时候一定要关闭。
- 4.监听器的使用

释放对象时，没有删除相应的监听器
#### 要点
- 1.程序员无权调用垃圾回收器
- 2.程序员可以调用System.gc()，该方法只是通知JVM，并不是运行垃圾回收器。尽量少用，会申请启动Full GC,成本高，影响系统性能。
- 3.finalize方法，是java提供给程序员用来释放对象或资源的方法，但是尽量少用。